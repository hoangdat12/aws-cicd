[
{
	"uri": "/",
	"title": "Implement CICD with AWS",
	"tags": [],
	"description": "",
	"content": "Implement CICD with AWS Overall In this lab, you\u0026rsquo;ll learn the basics and practice create AWS CICD with AWS.\nContent Introduction Preparation CICD Pipeline Deployment Strategies Implement with Terraform Clean up resources "
},
{
	"uri": "/3-cicdpipeline/3.1-codecommit/",
	"title": "Create CodeCommit Repository",
	"tags": [],
	"description": "",
	"content": "AWS CodeCommit is a source control service that is provided by Amazon Web Service which is fully managed. It is a version code service. It helps to manage and store assets such as codes or documents or any other type of file such as binary file etc. It allows the team to work collaboratively in a secure and highly scalable environment. It eliminates the need for third-party version control and also eliminates the need for your own source control system. You can work easily with your existing git tools by using the CodeCommit service.\nIn this step, we will create AWS Codecommit repository.\nCreate AWS Codecommit repository. Go to the AWS CodeCommit Console. Select Repositories. Click Create Repository. In Create repository. Enter client-app-repo. Click Create. We will do the same to create server-app-repo. Push code to the AWS Codecommit repository. Go to the AWS Cloud9 Console. Select My environments. Click Open. Push client-app-repo.\nIn Cloud9 Environment. Run the below command: git clone https://git-codecommit.\u0026lt;Your-AWS-Region\u0026gt;.amazonaws.com/v1/repos/\u0026lt;Your-AWS-Repo-Name\u0026gt;. Make sure to adjust Your-AWS-Region and Your-AWS-Repo-Name.\nNext, we need to run the command mv ./client-app-repo/.git ./Lab-repo/client-app-repo/ to coppy .git file from the client-app-repo folder to the my client-app.\nTo make sure that move command executes successfully, we wil run the following command ls -a ./Lab-repo/client-app-repo/ to see:\nThe result will be like this:\nNavigate to the client-app-repo folder cd Lab-repo/client-app-repo To push code to the Codecommit repository, we will run the following below commands: git add . \u0026amp;\u0026amp; git commit -m \u0026#34;first commit\u0026#34; \u0026amp;\u0026amp; git branch -M main \u0026amp;\u0026amp; git push -u origin main To make sure that the code is pushed successully, we need navigate to the CodeCommit Console and go to the client-app-repo, we will see like this: We will do the same to push server-app code into the Codecommit repository.\n"
},
{
	"uri": "/4-deployment/4.2-bluegreenservicelevel/4.2.1-createecsservice/",
	"title": "Create ECS Service",
	"tags": [],
	"description": "",
	"content": " Create ECS service. Go to the AWS Elastic Container Service Console. Select Clusters. Click Create. In Create service. Select Launch type. Select FARGATE with LATEST version. At Application type, choose Service. Select server-app-definition and version LATEST. Enter server-app-service-bluegreen. Select Replica. Click Deployment options. Select Blue/green deployment. Choose CodeDeployDefault.ECSAllAtOnce. Select codedeploy-role. At VPC. Select ECS-VPC. Select Public-subnet. Choose Use an existing security group and select Public-SG. At Load balancing. Choose Application Load Balancer. Select server-app 5000:5000. Click Create a new load balancer. Enter backend-bluegreen-alb. At Listeners. Click Create new listener. Enter port 80. Choose HTTP protocol. At Target groups. Click Create new target group. Enter tg-server-blue. Choose Target group protocol is HTTP. Enter Degrestration delay is 300. Choose Heal check protocol is HTTP and heal check path /. We will do the same to create Target group 2. Scroll down and click Create to complete. Go to the AWS CodeDeploy Console. Select Applications. We will see new application has been deployed for ECS Blue/Green service. .\n"
},
{
	"uri": "/2-prerequiste/2.1-createiamuser/",
	"title": "Create IAM User",
	"tags": [],
	"description": "",
	"content": "In this step, we will create an IAM User.\nCreate IAM User. Go to the AWS IAM Console. Select Users. Click Create user. In Specify user details. Enter lab-user. Select Provide user access to the AWS Management Console. Click I want to create an IAM user. Select Custom password. Click Next. In Set permissions. Search and select AdministratorAccess. Click Next. In Review and create. Click Create User. In Retrieve password. Select Download .csv file. Click Return to users list Get Access keys Go to the lab-user. Select Security credentials. Scroll down and in the Access keys. Click Create access key. In Access key best practices \u0026amp; alternatives. Select Command Line Interface (CLI). Check Confirmation. Click Next. In Set description tag. Enter Access Key for CICD Lab. Click Create access key. In Retrieve access keys. Select **Download .csv file. Click Done "
},
{
	"uri": "/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "AWS CICD Concepts AWS CI/CD refers to the continuous integration and continuous delivery/deployment (CI/CD) processes implemented using Amazon Web Services. These processes aim to automate the software development lifecycle, enabling frequent, reliable, and efficient software releases.\nAWS CI/CD Services AWS CodeCommit: A fully managed source control service that hosts Git repositories. It allows teams to store code securely and manage version control. AWS CodeBuild: A fully managed build service that compiles source code, runs tests, and produces software packages ready for deployment. CodeBuild scales continuously and processes multiple builds concurrently. AWS CodePipeline: A continuous integration and continuous delivery service for fast and reliable application and infrastructure updates. It automates the build, test, and deploy phases of your release process. AWS CodeDeploy: A deployment service that automates application deployments to a variety of compute services such as EC2, Fargate, Lambda, and on-premises servers. Benefits of AWS CI/CD Speed: Automating the build, test, and deployment process allows for quicker releases. Reliability: Automated tests and deployments reduce the risk of human error. Scalability: AWS services can handle large volumes of builds and deployments. Consistency: Automation ensures that each deployment follows the same process, reducing variability. ECS Concepts ECS Cluster is a logical grouping of EC2 instances or Fargate tasks on which your containers are running. When you create an ECS cluster, you can launch tasks and services on the instances within that cluster. The cluster serves as the foundational layer where all the other ECS resources operate.\nECS task definition is a blueprint that describes how Docker containers should run. It specifies parameters like:\nWhich Docker image to use for the containers. The resources the containers will use (CPU and memory). Networking settings. Environment variables. Links between containers. Storage volumes. ECS Service enables you to run and maintain a specified number of instances of a task definition simultaneously in an ECS cluster. Services ensure that the desired number of tasks are running and can restart tasks if they fail (due to issues with the application, an EC2 instance failure, etc.). You can also use services to load balance across tasks, using an Elastic Load Balancer (ELB).\nECS Task is an instantiation of a task definition. When you run a task, ECS launches the containers defined in your task definition on your cluster. Tasks can be run as part of a service, which ensures a specified number of them are always running, or as standalone tasks, which can be started and stopped manually or triggered by events.\nCode Code to be used in this lab here\n"
},
{
	"uri": "/3-cicdpipeline/3.5-reviewstage/3.5.1-prerequiste/",
	"title": "Prerequiste",
	"tags": [],
	"description": "",
	"content": "AWS CodeDeploy is a service that automates software deployments. One can deliver new features more quickly, avoid application deployment downtime, and handle the complexity of application updates with AWS CodeDeploy. Software deployments can be automated with the help of CodeDeploy, eliminating the necessity for laborious manual tasks. CodeDeploy can customize services that will favor the deployment of your application.\nAmazon Simple Notification Service (Amazon SNS) is a managed service that provides message delivery from publishers to subscribers (also known as producers and consumers). Publishers communicate asynchronously with subscribers by sending messages to a topic, which is a logical access point and communication channel. Clients can subscribe to the SNS topic and receive published messages using a supported endpoint type, such as Amazon Data Firehose, Amazon SQS, AWS Lambda, HTTP, email, mobile push notifications, and mobile text messages (SMS).\nIn this step, we need to create a CodeBuild project, CodeDeloy application and SNS topic.\nCreate Build-Stagging project. Go to the AWS CodeBuild Console. Select Build projects. Click Create project. In Create build project. Enter build-stagging. In Source. Select AWS CodeCommit. Select server-app-repo repository. Choose Branch. Select main. In Environment. Select Existing service role. Choose codebuild-role. In Buildspec. Enter buildstagingspec.yml. Scroll down and click Create build project. Create server-app-deploy-prj application. Go to the AWS CodeDeploy Console. Select Applications. Click Create application. In Create application. Enter server-app-deploy-prj. Choose EC2/On-premises. Click Create application. A deployment application in AWS CodeDeploy represents the application that you want to deploy. It serves as a container for the configuration and settings required to deploy your application.\nIn server-app-deploy-prj. Select Deployment groups. Click Create deployment group. In Create deployment group. At Deployment group name, enter server-app-deployment-group. At Service role, select codedeploy-role. At Environment Configuration. Select Amazon EC2 instances. Add Tags with key Environment - value Staging and key Name - value Stagging-Stack-WebServer. CodeDeploy will use these tags to identify EC2 instances to deploy new versions of your code.\nSelect CodeDeployDefault.AllAtOnce. Click Create deployment. A deployment group is a critical component within a CodeDeploy application that defines the set of instances (or other compute resources) and the deployment configuration settings that CodeDeploy uses to deploy your application.\nCreate SNS topic. Go to the Amazon SNS Console. Select Topics. Click Create topic. In Create topic. Choose Standard. Enter PipelineNotification. Scroll down and click Create topic. In AWS SNS Console. Select Subscriptions. Click Create subscription. In Create subscription. Select PIpelineNotification. Select Email protocol. Enter your email. Scroll down and click Create subscription. Sign in to your email and confirm. "
},
{
	"uri": "/4-deployment/4.3-bluegreenclusterlevel/4.3.1-prerequiste/",
	"title": "Prerequiste",
	"tags": [],
	"description": "",
	"content": " Deploy Dev Infrastructure. Go to the AWS Cloud9 Console. Select My environments. Click Open. Upload Terraform config for dev cluster. In Cloud9 Environment. Click File. Click Upload Local Files. Click Select files and choose these file that we have just downloaded. Execute these below commands to deploy infrastructure: terraform validate terraform plan terraform apply --auto-approve Create Dev Branch. Go to the AWS CodeCommit Select Repositories. Click server-app-repo. In server-app-repo. Select Branches. Click Create branch. In Create branch. Enter dev. Select main. Click Create branch. Create CodeBuild project for dev pipeline. To create CodeBuild project, we will do the same with Create CodeBuild for client-app-build-prj We will replace dev-server-app-build-prj name and dev branch. "
},
{
	"uri": "/4-deployment/4.1-rollingupdate/",
	"title": "Rolling Update",
	"tags": [],
	"description": "",
	"content": "In this step, we will learn about Rolling Update.\nUpdate Task desire. Go to the Amazon Elastic Container Service Select Clusters. Select lab-cluster. In lab-cluster. Choose server-app-service. Click Update. In Update server-app-service. At Desired tasks, adjust to 2. Scroll down and click Update. Min running tasks specify the least number of tasks that must be running and healthy at any time for the service to be considered healthy. This ensures a baseline level of availability and resilience.\nMax running tasks refer to the upper limit of tasks that can run simultaneously within a service. This is particularly relevant during deployments or scaling events.\nRelease new version. Go to the AWS CodeCommit Console. Select Repositories. Click server-app-repo. In server-app-repo, navigate to the index.js file. Click Edit. At Health check endpoint Replace with the below code: app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.status(200).json({ msg: \u0026#39;Release version 2\u0026#39; }); }); Fill out the blank. Click Commit change. Wait a few minutes, Navigate to the backend-pipeline. You will see like this: Click Review. Choose Approve. Click Submit. Go to the Amazon Elastic Container Service Select Clusters. Select lab-cluster. Click server-app-service. Click Deployments. We will see the older version being replaced by the new version: Verify new release. After deploy success, Go to the AWS EC2 Console Select Load Balancers. Choose Backend-LB and copy DNS name. Opening in a new tab, we will see new version has been deployed. "
},
{
	"uri": "/3-cicdpipeline/3.5-reviewstage/3.5.2-addreviewstage/",
	"title": "Add Review Stage",
	"tags": [],
	"description": "",
	"content": "\nIn this step, we will create a Review stage.\nCreate Stagging Stage and add Build-Stagging stage. Go to the AWS CodePipeline Console. Select Pipelines. Click backend-pipeline. Select Edit. In Editing: backend-pipeline. Select Add stage. Enter Review. Click Add stage. Select Add action group. Enter Build-Stagging. Choose AWS CodeBuild. Select SourceArtifact. Select build-stagging project. At Output artifacts, enter BuildStaggingArtifact. Click Done. Add Deploy-Infrastructure stage. Select Add action group. In Edit action. At Action name, enter Deploy-Infrastructure. At Action provider, select AWS CloudFormation. At Input artifacts, select SourceArtifact. At Action mode, select Replace a failed stack. At Stack name, enter Stagging-Stack. At Template, select SourceArtifact and enter cloudformation/staging-stack-template.yaml. In Capabilities, select CAPACITY_IAM. In Role name, select codedeploy-access-cloudformation. In Variable namespace, enter DeployInfrastructureVariables. Click Done. Add Deploy-Stagging stage. Select Add action group. In Edit action. At Action name, enter Deploy-Stagging. At Action provider, select AWS CodeDeploy. At Input artifacts, select BuildStaggingArtifact. At Application name, select server-app-deploy-prj. At Deployment group, enter server-app-deployment-group. Click Done. Add Manual-Approve stage. Select Add action group. In Edit action. At Action name, enter Manual-Approve. At Action provider, select Manual Approve. At SNS topic ARN, select PipelineNotification. At URL for review, enter http://#{DeployInfrastructureVariables.WebServerDnsName}:5000. Click Done. DeployInfrastructureVariables is the variable name we created in the Deploy Infrastructure Phase, it will use these output when we instantiate resources using CloudFormation.\nAdd Delete-Infrastructure stage. After approving the new deployment, we need to delete the infrastructure created during the Infrastructure Deployment stage to minimize resources and reduce costs Select Add action group. In Edit action. At Action name, enter Deploy-Infrastructure. At Action provider, select AWS CloudFormation. At Action mode, select Delete a stack. At Stack name, enter Stagging-Stack. Scroll down and click Done. Once done, we will click Done. Scroll up and click Save. "
},
{
	"uri": "/4-deployment/4.2-bluegreenservicelevel/",
	"title": "Blue Green Service Level",
	"tags": [],
	"description": "",
	"content": "Overview A blue/green deployment is a deployment strategy in which you create two separate, but identical environments. One environment (blue) is running the current application version and one environment (green) is running the new application version. Using a blue/green deployment strategy increases application availability and reduces deployment risk by simplifying the rollback process if a deployment fails. Once testing has been completed on the green environment, live application traffic is directed to the green environment and the blue environment is deprecated.\nThe blue/green approach reduces deployment risk in a number of ways:\nIt allows the newly deployed environment to be tested before routing production traffic to it. It enables immediate switchover from the old version to the new version, avoiding any inconsistencies that might arise when using an in-place rolling update. If an issue is detected after making the new version go live, it enables instant rollback to the previous version. Blue/Green Deployment at Service Level At the Service level, blue/green deployment involves having two versions of your application or service running simultaneously. One version (Blue) is the current live version, and the other (Green) is the new version you are planning to deploy. The process typically follows these steps:\nDeploy Green Environment. Test Green Environment. Switch Traffic. Monitor and Rollback (if needed). Decommission Blue Environment. Architecture To support blue/green deployments for the backend server we use two target groups tg-server-blue and tg-server-green on the production load balancer.\nThe port 80 listener on the ALB is configured to forward traffic with the path / to one of these target groups. Any new version of the application is deployed to the other group, and once it is up and running CodeDeploy switches target group to make the new version go llive.\nContent 4.2.1 Create ECS Service 4.2.2 Create new Pipeline 4.2.3 Release new version 4.2.3 Roll back "
},
{
	"uri": "/2-prerequiste/2.2-cloud9/",
	"title": "Create Cloud9 Environment",
	"tags": [],
	"description": "",
	"content": "AWS Cloud9 is an integrated development environment, or IDE. The AWS Cloud9 IDE offers a rich code-editing experience with support for several programming languages and runtime debuggers, and a built-in terminal. It contains a collection of tools that you use to code, build, run, test, and debug software, and helps you release software to the cloud.\nIn this step, we need to set up a Cloud9 environment to save Backend and Fronend code and we also use to create resources.\nCreate Cloud9 Environment. Go to the AWS Cloud9 Console. Select My environments. Click Create environment. In Create environment. Enter lab-environment. Select New EC2 instance. At New EC2 instance, select t2.micro. Scroll down and click Create. After completing to creation of the Cloud9 environment, we can click Open to access the Cloud9 environment. Install Terraform. Install yum-config-manager to manage your repositories. sudo yum install -y yum-utils Use yum-config-manager to add the official HashiCorp Linux repository. sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/AmazonLinux/hashicorp.repo Install Terraform from the new repository. sudo yum -y install terraform To verify that the installation worked by opening a new terminal session and listing Terraform\u0026rsquo;s available subcommands. terraform -help Turn off AWS managed temporary credentials In Cloud9 Environment. Click Setting icon. Select AWS Settings. Turn off AWS managed temporary credentials. In this lab, we need to turn off AWS managed temporary credentials to use the IAM User that we created in the previous step.\nWe will then run the command below and use the credentials file we just downloaded in the previous step: aws configure "
},
{
	"uri": "/3-cicdpipeline/3.2-codebuild/",
	"title": "Create CodeBuild Project",
	"tags": [],
	"description": "",
	"content": "AWS CodeBuild is a fully managed build service in the cloud. CodeBuild compiles your source code, runs unit tests, and produces artifacts that are ready to deploy. CodeBuild eliminates the need to provision, manage, and scale your own build servers.\nIn this step, we will create AWS Codebuild project.\nCreate AWS Codebuild project. Go to the AWS CodeBuild Console. Select Build projects. Click Create project. In Create build project. Enter client-app-build-prj. At Source provider, select AWS CodeCommit. Select client-app-repo. Select main branch. In AWS CodeBuild, the source attribute is used to specify the source code for your project. It determines where CodeBuild will retrieve the source code from to execute the build process.\nAt Environment, select On-demand. Select Managed image and EC2. At Service role, choose Existing service role. Select codebuild-role. In Additional configuration, scroll down and at Environment variables. Add AWS_ACCOUNT_ID environment. Granting an IAM role is necessary to provide the CodeBuild service with permissions to perform actions within your AWS environment.\nAt Buildspec, choose Use a buildspec file. Enter buildspec.yml. Scroll down and click Create build project. We will do the same to create server-app-build-prj.\n"
},
{
	"uri": "/4-deployment/4.2-bluegreenservicelevel/4.2.2-createnewpipeline/",
	"title": "Create new Pipeline",
	"tags": [],
	"description": "",
	"content": " Create CodePipeline. Go to the AWS CodePipeline Console. Select Pipelines. Click Create pipeline. In Choose pipeline settings step. Enter backend-pipeline-bluegreen. Select Queued. Select Existing service role. Choose codepipeline-role.' Scroll down and click Next. In Add source stage step. Select AWS CodeCommit. Enter server-app-repo. Select main branch. Scroll down and click Next. In Add build stage step. Select CodeBuild. Choose server-app-build-prj. Scroll down and click Next. In Add deploy stage step. Select Amazon ECS(Blue/Green). At Application name, select AppECS-lab-cluster-server-app-service-bluegreen. At Deployment group, select DgpECS-lab-cluster-server-app-service-bluegreen. At Amazon ECS task definition, select BuildArtifact and enter taskdef.json. At AWS CodeDeploy AppSpec file, select BuildArtifact and enter appspec.json. At Input artifact with image details, select BuildArtifact and enter SERVER_APP_IMAGE. Click Next. At Review stage, click Create pipeline.\nAfter creating the pipeline, the Pipeline will be executed automatically, we need to stop the current deployment.\nGo to the AWS CodeDeploy Console.\nSelect Deployments.\nSelect Newest deployment.\nClick Stop deployment.\n"
},
{
	"uri": "/4-deployment/4.3-bluegreenclusterlevel/4.3.2-devpipeline/",
	"title": "Create Pipeline for the Dev Environment",
	"tags": [],
	"description": "",
	"content": " Create Dev Pipeline. Go to the AWS CodePipeline Console Select Pipelines. Click Create pipeline. In Choose pipeline settings. Enter dev-backend-pipeline. Choose Existing Service Role Select codepipeline-role. Click Next In Add source stage. Select AWS CodeCommit. Select server-app-repo repository. Select dev branch. Scroll down and click Next. In Add build stage. Select AWS CodeBuild. Select dev-server-app-build-prj project. Scroll down and click Next. In Add deploy stage. Select AWS ECS. Select lab-cluster-dev cluster. Select server-app-service-dev service. Enter imagedefinitions.json. Scroll down and click Next. At Review, we need to click Create pipeline. Edit dev branch. We will do the same Release new version to edit dev branch code.\nAt Health check endpoint\nReplace with the below code:\napp.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.status(200).json({ msg: \u0026#39;Dev Cluster\u0026#39; }); }); Go to the AWS EC2 Console Select Load Balancers. Copy Dev-Backend-LB DNS name. Wait a few minus, your Pipeline will be completed, you need to open in new tabs and we see like this: Create pull request. Go to the AWS CodeCommit Console Select pull requests. Click Create pull request. In Create pull request. At Destination, select main. At Source, select dev. Click Compare. After create a pull request, we need merge from dev to main branch. Click Merge. In Merge pull request 1. We will click Merge pull request. After we Merge pull request, the backend-pipeline will be executed to deploy new version code. Verify new version code. Wait a few minus, go to the AWS EC2 Console Select Load Balancers. Copy Backend-LB DNS name. Open in new tabs and we see like this: "
},
{
	"uri": "/2-prerequiste/",
	"title": "Preparation ",
	"tags": [],
	"description": "",
	"content": "Overview In this step, we need to create an IAM User to grant permission for these service that we use in this lab, create a AWS Cloud9 to save and execute code, create a Amazon Elastic Container Registry (Amazon ECR) to save Docker images and use terraform to create resources that we use in this lab.\nAWS Cloud9 is an integrated development environment, or IDE. The AWS Cloud9 IDE offers a rich code-editing experience with support for several programming languages and runtime debuggers, and a built-in terminal. It contains a collection of tools that you use to code, build, run, test, and debug software, and helps you release software to the cloud.\nAmazon Elastic Container Registry (Amazon ECR) is an AWS managed container image registry service that is secure, scalable, and reliable. Amazon ECR supports private repositories with resource-based permissions using AWS IAM. This is so that specified users or Amazon EC2 instances can access your container repositories and images. You can use your preferred CLI to push, pull, and manage Docker images, Open Container Initiative (OCI) images, and OCI compatible artifacts.\nTerraform is an infrastructure as code tool that lets you define both cloud and on-prem resources in human-readable configuration files that you can version, reuse, and share. You can then use a consistent workflow to provision and manage all of your infrastructure throughout its lifecycle. Terraform can manage low-level components like compute, storage, and networking resources, as well as high-level components like DNS entries and SaaS features.\nContent 2.1 Create IAM User 2.2 Create Cloud9 Environment 2.3 Create ECR Repo 2.4 Resource Initialization "
},
{
	"uri": "/4-deployment/4.3-bluegreenclusterlevel/",
	"title": "Blue Green Service Level",
	"tags": [],
	"description": "",
	"content": "Overview Blue/Green Deployment at Cluster Level At the cluster level, blue/green deployment involves managing entire clusters of resources. In this lab, we will separate two cluster accross two VPCs. The process to implement Blue/Green Deployment at Cluster level typically follows these steps:\nCreate VPCs and these necessary resources. Provision Green Cluster. Deploy and Configure Green Cluster. Test Green Cluster. Switch Traffic. Monitor and Rollback (if needed). Decommission Blue Cluster. Content 4.3.1 Prerequiste 4.3.2 Create Pipeline for the Dev Enviroment "
},
{
	"uri": "/3-cicdpipeline/",
	"title": "CICD Pipeline",
	"tags": [],
	"description": "",
	"content": "Overview CI/CD is indeed a crucial phase of the software development cycle. It\u0026rsquo;s the backbone of modern software development methodologies and helps organizations avoid bugs and code failures while maintaining a continuous cycle of software development and updates.\nCI/CD Concepts What is CI/CD? Continuous Integration (CI): The practice of merging all developer working copies to a shared mainline multiple times a day.\nContinuous Delivery (CD): An approach in which teams produce software in short cycles, ensuring that the software can be reliably released at any time, but which still relies on human intervention to determine what gets pushed into production.\nContinuous Deployment: takes continuous delivery a step further by automatically deploying all releases into production. Whereas continuous delivery mandates that sofware can be reliably released at any time, it does not require that every release is in fact released to production.\nHow does AWS enable CI/CD? AWS provides a number of services that make it easy to build CI/CD pipelines, and to be able to template these pipelines so that they can be re-used for multiple services.\nRelevant AWS services include:\nAWS CodeCommit for source code repositories AWS CodeBuild for building service artifacts AWS CodeDeploy for deploying artifacts into environments AWS CodePipeline to manage the end-to-end control flow of a change from source through to deployment. AWS CloudFormation to deploy and update infrastructure resources. In this step, we will implement a basic CICD pipeline with AWS.\nContent 3.1 Create CodeCommit Repository 3.2 Create CodeBuild Project 3.3 Create Frontend CICD Pipeline 3.4 Create Back CICD Pipeline 3.5 Add Manual Approve Stage "
},
{
	"uri": "/2-prerequiste/2.3-createecrrepo/",
	"title": "Create Cloud9 Environment",
	"tags": [],
	"description": "",
	"content": "Amazon Elastic Container Registry (Amazon ECR) is an AWS managed container image registry service that is secure, scalable, and reliable. Amazon ECR supports private repositories with resource-based permissions using AWS IAM. This is so that specified users or Amazon EC2 instances can access your container repositories and images. You can use your preferred CLI to push, pull, and manage Docker images, Open Container Initiative (OCI) images, and OCI compatible artifacts.\nIn this step, we need to create ECR repository for my frontend and backend app.\nMake sure that edit AWS-Region and AWS-Account-ID in taskdef.json file.\nThis code we will use here\nCreate ECR repository. Go to the AWS ECR Console. Select Repositories. Click Create repository. In Create repository. Enter client-app. Scroll down and click Create repository. We will do the same to create server-app.\nUpload source code to Cloud9 Environment. Go to the AWS Cloud9 Console. Select My environments. Click Open. In Cloud9 Environment. Select File. Select Upload local Files. Unzip and upload file that we downloaded. Navigate to the Lab-repo folder cd Lab-repo Push Image to the ECR repository. We need push code to the client-app repo.\nTo see the Push Image to repository command, we will find the repository and click View push commands.\nNavigate to the client code with command cd client-app-repo\nRetrieve an authentication token and authenticate your Docker client to your registry.\nMake sure to adjust Your-AWS-Region and Your-AWS-Account-ID.\naws ecr get-login-password --region \u0026lt;Your-AWS-Region\u0026gt; | docker login --username AWS --password-stdin \u0026lt;Your-AWS-Account-ID\u0026gt;.dkr.ecr.\u0026lt;Your-AWS-Region\u0026gt;.amazonaws.com Build your Docker image using the following command. docker build -t client-app . After the build completes, tag your image so you can push the image to this repository docker tag client-app:latest 918195417335.dkr.ecr.ap-southeast-1.amazonaws.com/client-app:latest Run the following command to push this image to your newly created AWS repository docker push 918195417335.dkr.ecr.ap-southeast-1.amazonaws.com/client-app:latest We wil do the same to push Backend Image.\n"
},
{
	"uri": "/3-cicdpipeline/3.3-frontendpipeline/",
	"title": "Create Frontend CICD pipeline",
	"tags": [],
	"description": "",
	"content": "\nAWS CodePipeline is a continuous delivery service you can use to model, visualize, and automate the steps required to release your software. You can quickly model and configure the different stages of a software release process. CodePipeline automates the steps required to release your software changes continuously.\nIn this step, we will create Frontend CICD pipeline.\nCreate Frontend CICD pipeline. Go to the AWS CodePipeline Console. Select Pipelines. Click Create pipeline. At Choose pipeline settings step. Enter client-pipeline. Choose Existing service role and select codepipeline-role. Scroll down and click Next. At Add source stage step. Select AWS CodeCommit. Select client-app-repo repository and branch main. Click Next. At Add build stage step. Select AWS CodeBuild. Select client-app-build-prj project. Click Next. At Add deploy stage step. In this deployment phase, we will use Rolling update strategy for deloyment.\nSelect Amazon ECS. Choose lab-cluster cluster. Choose client-app-service service. Enter imagedefinitions.json. Click Next At Review step. Click Create pipeline. Wait a couple minus, the pipeline will be executed success: Now, after that, we will open my website to verify. Go to the ECS-LB and copy DNS mame. Open in new tab and we will see: You can test some feature in your website to make sure that it working exactly.\nRelease new version. To make sure that my pipeline execute exact, we will following these below steps:\nGo to the CodeCommit repository. Select client-app-repo. Open src/App.jsx file. Click Edit. Add the below code: \u0026lt;h2 className=\u0026#39;title\u0026#39;\u0026gt;Version: 1\u0026lt;/h2\u0026gt; At Author name and Email address, enter any name that you want. Click Create commit changes. Go to my pipeline, we will see it automatic trigger. Wait a few minus, when the pipeline execute sucessully, go to the website and we will ses the new version is updated. "
},
{
	"uri": "/4-deployment/4.2-bluegreenservicelevel/4.2.3-releasenewversion/",
	"title": "Release new version",
	"tags": [],
	"description": "",
	"content": " Release new version. Go to the AWS CodeCommit Console. Select Repositories. Click server-app-repo. In server-app-repo, navigate to the index.js file. Click Edit. At Health check endpoint Replace with the below code: app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.status(200).json({ msg: \u0026#39;New version for Blue/Green\u0026#39; }); }); Fill out the blank. Click Commit change. Verify new version. Go to the AWS EC2 Console. Select Load Balancers. Select backend-bluegreen-alb and copy DNS name. Open in new tabs, we will see like this: "
},
{
	"uri": "/3-cicdpipeline/3.5-reviewstage/3.5.3-testnewpipeline/",
	"title": "Test new pipeline",
	"tags": [],
	"description": "",
	"content": "AWS CodePipeline is a continuous delivery service you can use to model, visualize, and automate the steps required to release your software. You can quickly model and configure the different stages of a software release process. CodePipeline automates the steps required to release your software changes continuously.\nIn this step, we will create Backend CICD pipeline.\nRelease new version. In backend-pipeline. Click Release change. Click Release. Verify new version Wait a couple of minus, we will received an email that notify new version was released. At Manual-Approve action. Click Review. At URL for review. Click URL. We will see like this: After verify new release, click Approve. Click Submit. Wait a moment, the new release will be deployed. "
},
{
	"uri": "/4-deployment/4.4-canary/",
	"title": "Canary Deployment",
	"tags": [],
	"description": "",
	"content": "Canary Deployment involves deploying the new version to a small subset of users or tasks first before rolling it out more broadly. This strategy is often a part of Blue/Green deployments.\nIn this step, we will implement Canary Deployment with Blue/Green deployment.\nAt Service level. Go to the AWS CodeDeploy Console Click AppECS-lab-cluster-server-app-service-bluegreen. Select DgpECS-lab-cluster-server-app-service-bluegreen. Click Edit. In Edit deployment group. At Deployment settings, select CodeDeployDefault.ECSCanary10Percent5Minutes. Click Save changes. Go to the AWS CodePipeline Console. Select Pipelines. Click backend-bluegreen-pipeline. In backend-bluegreen-pipeline. Click Release change. Wait a few minutes and we will see the traffic will be transferred from the Original service to the Alternate Service. At Cluster level. With Cluster level, we can use AWS Route53\u0026rsquo;s Weighted Routing. Weighted routing lets you associate multiple resources with a single domain name (example.com) or subdomain name (acme.example.com) and choose how much traffic is routed to each resource. This can be useful for a variety of purposes, including load balancing and testing new versions of software. "
},
{
	"uri": "/3-cicdpipeline/3.4-backendpipeline/",
	"title": "Create Backend CICD pipeline",
	"tags": [],
	"description": "",
	"content": "\nAWS CodePipeline is a continuous delivery service you can use to model, visualize, and automate the steps required to release your software. You can quickly model and configure the different stages of a software release process. CodePipeline automates the steps required to release your software changes continuously.\nIn this step, we will create Backend CICD pipeline.\nCreate Backend CICD pipeline. Go to the AWS CodePipeline Console. Select Pipelines. Click Create pipeline. At Choose pipeline settings step. Enter backend-pipeline. Choose Existing service role and select codepipeline-role. Scroll down and click Next. At Add source stage step. Select AWS CodeCommit. Select server-app-repo repository and branch main. Click Next. At Add build stage step. Select AWS CodeBuild. Select server-app-build-prj project. Click Next. At Add deploy stage step. In this deployment phase, we will use Rolling update strategy for deloyment.\nSelect Amazon ECS. Choose lab-cluster cluster. Choose server-app-service service. Enter imagedefinitions.json. Click Next At Review step. Click Create pipeline. Wait a few minutes, the pipeline will be executed successfully: "
},
{
	"uri": "/4-deployment/",
	"title": "Deployment Strategy",
	"tags": [],
	"description": "",
	"content": "Overview In AWS CI/CD pipelines with Amazon ECS (Elastic Container Service), Deployment strategies define how new versions of your containerized applications are rolled out to your ECS services. Different strategies can help you balance the need for fast deployments with the desire to minimize downtime and avoid disruption to your users. Here are the main deployment strategies you can use with ECS and how they work:\nDeployment strategies Rolling Updae Rolling Update is the default deployment strategy in ECS. It updates a service’s tasks in a controlled way to ensure that a specified percentage of tasks are updated at a time, maintaining the desired number of tasks throughout the process.\nHow it work: ECS replaces tasks one by one or in batches, defined by the minimumHealthyPercent and maximumPercent parameters. The service scheduler ensures that the desired number of tasks remain running, starting new tasks before stopping the old ones.\nUse case: Suitable for many scenarios where some downtime or reduced capacity is acceptable during the deployment process.\nBlue/Green Deployment Blue/Green Deployment creates a new set of tasks (the green environment) alongside the existing set (the blue environment). Once the new version is verified, traffic is shifted from the old set to the new set.\nHow it works: AWS CodeDeploy or other deployment tools are used to manage the shift in traffic. CodeDeploy allows for gradual traffic shifting, where a small percentage of traffic is directed to the new version initially, with more traffic shifted over time based on success metrics.\nUse case: Ideal for reducing downtime and risk, as it allows you to test the new version in production with a subset of traffic and provides a quick rollback option if issues arise.\nCanary Deployment Canary Deployment involves deploying the new version to a small subset of users or tasks first before rolling it out more broadly. This strategy is often a part of Blue/Green deployments.\nHow it works: Similar to Blue/Green, but specifically focuses on initially routing a small percentage of traffic to the new version to monitor its performance and impact. If successful, the new version is gradually rolled out to all users.\nUse case: Used for safer, incremental deployments, reducing the risk of widespread failure by limiting initial exposure to potential issues.\nIn this step, we will learn about AWS CICD Deployment Strategies.\nContent 4.1 Rolling Update 4.2 Canary Deloyment 4.3 Blue/Green Deployment "
},
{
	"uri": "/2-prerequiste/2.4-initresource/",
	"title": "Resource initialization",
	"tags": [],
	"description": "",
	"content": "Terraform is an infrastructure as code tool that lets you define both cloud and on-prem resources in human-readable configuration files that you can version, reuse, and share. You can then use a consistent workflow to provision and manage all of your infrastructure throughout its lifecycle. Terraform can manage low-level components like compute, storage, and networking resources, as well as high-level components like DNS entries and SaaS features.\nIn this step, we will initial some resources that we will use in this lab.\nInitial resources. Go to the AWS Cloud9 Console. Select My environments. Click Open. Make sure that edit AWS-Region and AWS-Account-ID in terraform policies.\nThis terraform file that we\u0026rsquo;re going to use in this lab is here.\nWe need to upload the terraform file to the Cloud9 Environment.\nTo initialize AWS resources with Terraform, we need to following these below commands:\nNavigate to the terraform folder: cd terraform Initialize Terraform in your project directory (if not done already): terraform init Validate Terraform Configuration with command: terraform validate Review Terraform configuration (ensure you have written your .tf files defining your AWS resources): terraform plan Apply Terraform configuration: terraform apply --auto-approve The result will be like this:\nVerify To make sure that resoureces created succcesfully, we will navigate to the AWS EC2 Instance Select Load Balancers. Coppy ECS-LB DNS name and open in new tab. "
},
{
	"uri": "/4-deployment/4.2-bluegreenservicelevel/4.2.4-rollback/",
	"title": "Rollback Deployment",
	"tags": [],
	"description": "",
	"content": "Rollback deployment is a mechanism that allows you to revert your application to a previous, stable version in case the current deployment encounters issues. The effects and benefits of rollback deployment in AWS ECS include:\nMinimizing Downtime Maintaining Stability Automated Process Improved Reliability Reduced Risk Rollback manually. Go to the AWS CodeDeploy Console. Select Deployments. Select Newest deployment. Click Stop deployment. Wait a few minutes, the older version will be rollback. Go to the AWS EC2 Console. Select Load Balancers. Select backend-bluegreen-alb and copy DNS name. Open in new tabs, we will see like this: Rollback with CloudWatch Alarm. Create CloudWatch Metric Amazon CloudWatch is a monitoring and observability service. It provides data and actionable insights to monitor applications, understand and respond to system-wide performance changes, optimize resource utilization, and get a unified view of operational health.\nGo to the AWS CloudWatch Console. Select Log groups. Select ecs/server-app-service-bluegreen. Select Actions. Click Create metric filter. CloudWatch Metrics are data points collected over time that represent the performance of your resources and applications. It is collected based on CloudWatch Logs.\nIn Design pattern. Enter [host, logName, user, timestamp, request, statusCode=5*, size]. Scroll down and click Next. In Assign metric. Enter 5xRequestError. At Metric detail. Enter 5xRequestError. Metric name is 5xRequestError. Metric value is 1. Default value is 0. Select Count. In Review and create. Click Create metric filter. Create CloudWatch Alarm In CloudWatch Console, select All alarms. Click Create alarm CloudWatch Alarms help you react to changes in your metrics by sending notifications or automatically making changes to the resources you are monitoring based on predefined thresholds\nIn Specify metric and conditions. Click Select. Choose 5xRequestError. Choose Metric with no dimensions. Choose 5xRequestError and click Select. At Statitic, select sum. At Period, select 5 minutes. At Condition. Select Static. Select **Greater. Enter 5. Click Next. In Config actions. Select In alarm. Choose Select an existing SNS topic. Select PipelineNotification. Scroll down and click Next. In Add name and description. Enter detect-ecs-error-rollback. Click Next In Preview and create. Click Create. Update Deployment Group Go to the AWS CodeDeploy Console. Select Applications. Click AppECS-lab-cluster-server-app-service-bluegreen .\nSelect Deployment groups. Select DgpECS-lab-cluster-server-app-service-bluegreen. Click Edit. At Alarms. Click Add alarm. Search and choose detect-ecs-error-rollback. Select Continue deployment even if alarm status is unvailable. Select Roll back when alarm thresholds are met. Click Save changes. Update CodeCommit Go to the AWS CodeCommit Console. Select Repositories. Click server-app-repo. In server-app-repo, navigate to the index.js file. Click Edit. At Health check endpoint Replace with the below code: app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.status(200).json({ msg: \u0026#39;Rollback with Cloudwatch Alarm\u0026#39; }); }); Fill out the blank.\nClick Commit change.\nWait a few minutes, get backend-bluegreen-alb DNS name and open in new tabs we will see like this:\nUpdate URL https://backend-bluegreen-alb-1380015066.ap-southeast-1.elb.amazonaws.com/api/error Repeat this 6 times. We will see like this: Wait a few minutes, the rollback will be trigger. .\n"
},
{
	"uri": "/3-cicdpipeline/3.5-reviewstage/",
	"title": "Add Review Stage",
	"tags": [],
	"description": "",
	"content": "Overview In AWS CI/CD pipelines, the Review Stage is a critical checkpoint that requires human intervention before the pipeline can proceed to the next stage. This stage ensures that important checks, such as code review, security audits, or business approvals, are conducted before the application is deployed to production or another critical environment.\nIn this step, we will use AWS CloudFormation to create the EC2 instance and CodeDeploy to deploy new version on it.\nWe can use AWS EC2 to deploy new versions of your code.\nCodeDeploy interact with EC2 Tag the Amazon EC2 instance Identify Target Instances: During a deployment, CodeDeploy needs to know which EC2 instances should receive the new version of the application. Tags help in identifying these target instances.\nOrganize and Manage Resources: Tags help in organizing and managing your resources more effectively.\nFilter and Select Instances: Tags allow you to filter and select instances dynamically. This is especially useful in auto-scaling environments where instances may be frequently added or removed.\nInstall the AWS CodeDeploy agent on the Amazon EC2 instance Receives Deployment Instructions: The agent communicates with the CodeDeploy service to receive deployment instructions. These instructions include details about where to download the application revision, how to deploy it, and what scripts to run before, during, and after the deployment.\nExecutes Deployment Commands: The agent runs the deployment commands specified in the AppSpec file. This file contains the deployment lifecycle event hooks (such as BeforeInstall, AfterInstall, ApplicationStart, etc.) and the corresponding scripts or commands that should be executed at each stage.\nHandles Deployment Lifecycle Events: The agent ensures that the application is deployed correctly by handling all the defined lifecycle events. This includes tasks such as stopping the current application, copying new files, running database migrations, and starting the new application version.\nReports Status and Logs: The agent reports the status of each deployment step back to the CodeDeploy service. It also captures and uploads logs, which can be used for troubleshooting if any issues occur during the deployment.\nContent 3.5.1 Prerequiste 3.5.2 Add Review Stage 3.5.3 Test new Pipeline "
},
{
	"uri": "/6-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": "We will take the following steps to delete the resources we created in this exercise.\nDelete ECS Blue/Green Service Go to the AWS Elastic Container Service Console. Select Clusters. Click lab-cluster. In lab-cluster. Click server-app-service-bluegreen. Click Delete service. Delete Blue/Green Stack - CloudFormation. Go to the AWS CloudFormation Console. Select Stacks. Select ECS-Console-V2-Service-server-app-service-bluegreen-lab-cluster-. Click Delete Destroy Terraform Resources. Go to the AWS Cloud9 Console. Select My environments. Click Open. In Cloud9 Environment. Navigate to the terraform folder. cd terraform Then execute the below command to destroy Terraform Resources. terraform destroy --auto-approve The result will be like this: Delete IAM User Go to the AWS IAM Console Select Users. Select lab-user. Click Delete. Delete Cloud9 Environment. Go to the AWS Cloud9 Select My environments. Select lab-env. Click Delete. We will do the same to clean AWS CodeCommit repositories, AWS ECR, AWS CodePipeline, AWS CodeBuild projects and AWS CodeDeploy projects.\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]